<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <title>YDS Words</title>
    <link rel="icon" type="image/png" href="icon.png">
    <link rel="apple-touch-icon" href="icon.png">
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }

        html {
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        body {
            overflow-x: hidden;
            font-family: 'Crimson Pro', Georgia, serif;
            font-size: 1rem;
            line-height: 1.6;
            color: #1e293b;
            background: #fdfbf7;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           ERROR BOUNDARY & NOTIFICATION SYSTEM
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .global-error-boundary {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #fdfbf7;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 2rem;
            z-index: 10000;
            text-align: center;
        }

        .global-error-boundary.active {
            display: flex;
        }

        .global-error-boundary h2 {
            font-size: 1.5rem;
            color: #dc2626;
            margin-bottom: 1rem;
        }

        .global-error-boundary p {
            color: #64748b;
            margin-bottom: 1.5rem;
            max-width: 400px;
        }

        .global-error-boundary button {
            padding: 0.75rem 1.5rem;
            background: #1e293b;
            color: #fdfbf7;
            border: none;
            border-radius: 8px;
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
        }

        .notification-container {
            position: fixed;
            top: env(safe-area-inset-top, 0);
            left: 50%;
            transform: translateX(-50%);
            z-index: 9999;
            width: 90%;
            max-width: 400px;
            pointer-events: none;
        }

        .notification {
            margin-top: 0.5rem;
            padding: 1rem;
            border-radius: 10px;
            font-size: 0.9rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            animation: slideDown 0.3s ease;
            pointer-events: auto;
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .notification.error {
            background: #fef2f2;
            border: 1px solid #fecaca;
            color: #dc2626;
        }

        .notification.warning {
            background: #fffbeb;
            border: 1px solid #fde68a;
            color: #d97706;
        }

        .notification.info {
            background: #eff6ff;
            border: 1px solid #bfdbfe;
            color: #2563eb;
        }

        .notification.success {
            background: #f0fdf4;
            border: 1px solid #bbf7d0;
            color: #16a34a;
        }

        .notification-icon {
            flex-shrink: 0;
            width: 20px;
            height: 20px;
        }

        .notification-close {
            margin-left: auto;
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            opacity: 0.5;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .notification-close:hover {
            opacity: 1;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           SIMPLE WELCOME PAGE
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .welcome-container {
            max-width: 600px;
            margin: 0 auto;
            padding: 2rem 1.5rem;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .welcome-container.active {
            display: flex;
        }

        .welcome-icon {
            width: 96px;
            height: 96px;
            margin-bottom: 1.5rem;
            background: white;
            box-shadow: 0 4px 16px rgba(0,0,0,0.08);
        }

        .welcome-title {
            font-size: 2rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #1e293b;
        }

        .welcome-tagline {
            font-size: 1.1rem;
            color: #64748b;
            margin-bottom: 2.5rem;
        }

        .btn-start {
            width: 100%;
            max-width: 280px;
            min-height: 52px;
            padding: 1rem 2rem;
            background: #1e293b;
            color: #fdfbf7;
            border: none;
            border-radius: 12px;
            font-family: inherit;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 1rem;
            position: relative;
        }

        .btn-start:hover:not(:disabled) {
            background: #334155;
            transform: translateY(-2px);
        }

        .btn-start:active:not(:disabled) {
            transform: translateY(0);
            background: #475569;
        }

        .btn-start:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-start.loading::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            border: 2px solid transparent;
            border-top-color: #fdfbf7;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-left: 8px;
        }

        .welcome-note {
            font-size: 0.85rem;
            color: #94a3b8;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           APP STYLES
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .app {
            max-width: 600px;
            margin: 0 auto;
            padding: 0.75rem;
            padding-bottom: calc(0.75rem + env(safe-area-inset-bottom));
            display: none;
        }

        .app.active {
            display: block;
        }

        /* Header */
        .header {
            margin-bottom: 1rem;
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #e2e8f0;
            margin-bottom: 0.75rem;
        }

        .header h1 {
            font-size: 1rem;
            font-weight: 600;
        }

        .score {
            font-family: monospace;
            font-size: 0.8rem;
            color: #64748b;
            background: #f1f5f9;
            padding: 0.25rem 0.5rem;
            border-radius: 6px;
        }

        /* Loading */
        .loading {
            text-align: center;
            padding: 2rem 0;
        }

        .loading.hidden { display: none; }

        .spinner {
            width: 32px;
            height: 32px;
            border: 3px solid #e2e8f0;
            border-top-color: #1e293b;
            border-radius: 50%;
            margin: 0 auto 0.75rem;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .loading p {
            color: #64748b;
            font-size: 0.85rem;
        }

        /* Error State */
        .error-state {
            text-align: center;
            padding: 2rem 1rem;
            background: white;
            border: 1px solid #fecaca;
            border-radius: 10px;
            margin: 1rem 0;
        }

        .error-state.hidden { display: none; }

        .error-state h3 {
            color: #dc2626;
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }

        .error-state p {
            color: #64748b;
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }

        .error-state button {
            padding: 0.6rem 1.2rem;
            background: #1e293b;
            color: #fdfbf7;
            border: none;
            border-radius: 8px;
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
        }

        .error-state button:hover {
            background: #334155;
        }

        /* Question Area */
        .question-area {
            animation: fadeIn 0.3s ease;
        }

        .question-area.hidden { display: none; }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .sentence {
            font-size: 1.05rem;
            line-height: 1.7;
            margin-bottom: 1rem;
            padding: 1rem;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.04);
            overflow-wrap: break-word;
            word-wrap: break-word;
            hyphens: auto;
        }

        .blank {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            padding: 2px 12px;
            border-radius: 4px;
            border-bottom: 2px solid #f59e0b;
            font-weight: 500;
        }

        /* Options */
        .options {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .option {
            display: flex;
            align-items: center;
            gap: 0.65rem;
            min-height: 48px;
            padding: 0.7rem 0.85rem;
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.95rem;
            color: #1e293b;
            text-align: left;
            transition: all 0.15s ease;
            touch-action: manipulation;
            overflow-wrap: break-word;
            word-wrap: break-word;
        }

        .option:hover:not(:disabled) {
            border-color: #94a3b8;
        }

        .option:active:not(:disabled) {
            background: #f8fafc;
            transform: scale(0.98);
        }

        .option:disabled { cursor: default; }

        .option .key {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            background: #f1f5f9;
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.7rem;
            font-weight: 600;
            color: #64748b;
            flex-shrink: 0;
        }

        .option.correct {
            border-color: #10b981;
            background: #d1fae5;
        }

        .option.correct .key {
            background: #10b981;
            color: white;
        }

        .option.incorrect {
            border-color: #ef4444;
            background: #fee2e2;
        }

        .option.incorrect .key {
            background: #ef4444;
            color: white;
        }

        .option.revealed {
            border-color: #10b981;
            background: #d1fae5;
        }

        /* Feedback */
        .feedback {
            padding: 0.85rem;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            margin-bottom: 0.85rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.04);
        }

        .feedback.hidden { display: none; }

        .feedback p {
            font-size: 0.85rem;
            color: #64748b;
            line-height: 1.55;
        }

        .explanation-list {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid #e2e8f0;
        }

        .explanation-item {
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 0.8rem;
            line-height: 1.5;
        }

        .explanation-item:last-child {
            margin-bottom: 0;
        }

        .explanation-item .opt-label {
            flex-shrink: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .explanation-item.correct .opt-label {
            background: #10b981;
            color: white;
        }

        .explanation-item.wrong .opt-label {
            background: #ef4444;
            color: white;
        }

        .explanation-item .opt-text {
            color: #475569;
        }

        /* Button */
        .btn-next {
            width: 100%;
            min-height: 48px;
            padding: 0.8rem;
            background: #1e293b;
            color: #fdfbf7;
            border: none;
            border-radius: 10px;
            font-family: inherit;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            touch-action: manipulation;
            position: relative;
        }

        .btn-next:hover:not(:disabled) {
            background: #334155;
        }

        .btn-next:active:not(:disabled) {
            background: #475569;
            transform: scale(0.98);
        }

        .btn-next:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-next.hidden { display: none; }

        .btn-next.loading::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            border: 2px solid transparent;
            border-top-color: #fdfbf7;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-left: 8px;
        }

        /* Back button */
        .btn-back {
            background: none;
            border: none;
            color: #64748b;
            font-family: inherit;
            font-size: 0.8rem;
            cursor: pointer;
            padding: 0.25rem 0;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .btn-back:hover {
            color: #1e293b;
        }

        .btn-back svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        /* Offline Indicator */
        .offline-indicator {
            display: none;
            background: #fef3c7;
            color: #92400e;
            padding: 0.5rem 1rem;
            font-size: 0.8rem;
            text-align: center;
            border-bottom: 1px solid #fde68a;
        }

        .offline-indicator.active {
            display: block;
        }

        /* Mobile */
        @media (max-width: 390px) {
            .welcome-container {
                padding: 1.5rem 1rem;
            }

            .welcome-icon {
                width: 80px;
                height: 80px;
                margin-bottom: 1rem;
            }

            .welcome-title {
                font-size: 1.6rem;
            }

            .welcome-tagline {
                font-size: 1rem;
                margin-bottom: 2rem;
            }

            .app {
                padding: 0.5rem;
            }

            .sentence {
                font-size: 0.95rem;
                padding: 0.75rem;
            }

            .option {
                font-size: 0.9rem;
                min-height: 44px;
            }

            .notification-container {
                width: 95%;
            }
        }
    </style>
</head>
<body>
    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         GLOBAL ERROR BOUNDARY
         â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div class="global-error-boundary" id="globalErrorBoundary">
        <h2>ğŸ˜… Something went wrong</h2>
        <p>We encountered an unexpected error. Don't worry - your progress is safe. Try refreshing the page to continue learning.</p>
        <button onclick="window.location.reload()">Refresh Page</button>
    </div>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         NOTIFICATION CONTAINER
         â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div class="notification-container" id="notificationContainer"></div>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         OFFLINE INDICATOR
         â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div class="offline-indicator" id="offlineIndicator">
        âš ï¸ You're offline. Check your connection to continue.
    </div>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         SIMPLE WELCOME PAGE
         â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div class="welcome-container active" id="welcomePage">
        <img src="icon.png" alt="YDS Words" class="welcome-icon" id="welcomeIcon">
        <h1 class="welcome-title">YDS Words</h1>
        <p class="welcome-tagline">Master academic vocabulary through practice</p>
        <button class="btn-start" id="btnStart">Start Learning</button>
        <p class="welcome-note">Press 1-5 or A-E to answer â€¢ Enter for next</p>
    </div>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         APP PAGE
         â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div class="app" id="appPage">
        <button class="btn-back" id="btnBack">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
            </svg>
            Back
        </button>

        <header class="header">
            <div class="header-top">
                <h1>YDS Words</h1>
                <div class="score" id="score">0 / 0</div>
            </div>
        </header>

        <div class="loading hidden" id="loading">
            <div class="spinner"></div>
            <p id="loadingText">Generating question...</p>
        </div>

        <div class="error-state hidden" id="errorState">
            <h3>âš ï¸ Couldn't load question</h3>
            <p id="errorMessage">Something went wrong. Please try again.</p>
            <button id="btnRetry">Try Again</button>
        </div>

        <main class="question-area hidden" id="questionArea">
            <p class="sentence" id="sentence"></p>
            <div class="options" id="options"></div>
            <div class="feedback hidden" id="feedback">
                <p id="feedbackText"></p>
            </div>
            <button class="btn-next hidden" id="btnNext">Next â†’</button>
        </main>
    </div>

    <!-- Word list -->
    <script src="mywords.js"></script>

    <script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DEFENSIVE CONFIGURATION & CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const CONFIG = {
    model: 'mistral-small-latest',
    temperature: 0.8,
    maxTokens: 1024,
    
    // Timeouts and rate limiting
    apiTimeout: 30000,           // 30 second API timeout
    retryAttempts: 3,            // Number of retry attempts
    retryDelay: 1000,            // Initial retry delay (ms)
    debounceDelay: 300,          // Button debounce delay
    
    // Circuit breaker settings
    circuitBreakerThreshold: 5,  // Failures before opening circuit
    circuitBreakerTimeout: 60000, // Time before trying again (1 min)
    
    // Input validation
    maxSentenceLength: 2000,     // Max characters in sentence
    maxOptionLength: 500,        // Max characters per option
    
    getPrompt: function(word) {
        // DEFENSE: Validate word before using in prompt
        if (!word || typeof word !== 'string') {
            throw new Error('Invalid word provided to prompt generator');
        }
        
        // DEFENSE: Escape special characters that could affect JSON
        const sanitizedWord = word
            .replace(/\\/g, '\\\\')
            .replace(/"/g, '\\"')
            .substring(0, 100); // Limit word length
            
        const isMultiWord = sanitizedWord.includes(' ');
        const typeHint = isMultiWord
            ? `IMPORTANT: "${sanitizedWord}" is a multi-word expression. ALL 5 options must be multi-word expressions of the same type (e.g., all phrasal verbs, all prepositional phrases, or all connectors). Do NOT mix single words with multi-word expressions.`
            : '';

        return `You are an academic English instructor. Create ONE fill-in-the-blank question.

The correct answer MUST be: "${sanitizedWord}"

${typeHint}

CRITICAL: Vary the sentence context based on the word's meaning. Do NOT default to "research study" contexts. Choose contexts that match the word's natural usage:
- For nature/environment words: use environmental, seasonal, or ecological contexts
- For business/economic words: use corporate, financial, or market contexts  
- For social/emotional words: use interpersonal, psychological, or societal contexts
- For technical words: use technological, scientific, or mechanical contexts
- For abstract/conceptual words: use philosophical, theoretical, or analytical contexts

Requirements:
- Write a sentence (25-40 words) with rich context where "${sanitizedWord}" is the ONLY natural fit in the blank _____
- Include specific details (setting, subject matter, relationships between ideas) to make the correct choice unambiguous
- The sentence should feel authentic to academic writing (research papers, essays, lectures, or formal discussions)
- Provide exactly 5 options including "${sanitizedWord}" - all options must be the same grammatical type
- "${sanitizedWord}" must be the correct answer (index 0)
- Other 4 options should be plausible distractors that would NOT fit naturally given the specific context
- For EACH option, explain why it is correct or wrong based on the specific context clues in the sentence

EXAMPLES of diverse contexts (for illustration only - create appropriate context for "${sanitizedWord}"):

Example 1 (Nature context for "blossom"): The once-barren hillsides began to _____ with wildflowers after the spring rains returned, transforming the arid landscape into a vibrant tapestry of purple and yellow blooms.

Example 2 (Business context for "merge"): The two rival pharmaceutical companies decided to _____ their operations after months of negotiation, creating the largest healthcare conglomerate in European history.

Example 3 (Social context for "alienate"): The politician's harsh rhetoric managed to _____ even his most loyal supporters, who felt betrayed by his sudden shift toward extreme ideological positions.

Example 4 (Technical context for "disrupt"): The innovative startup aimed to _____ the traditional banking sector by offering instant peer-to-peer transactions without intermediaries or excessive processing fees.

Respond with JSON only:
{
  "sentence": "Your contextually appropriate sentence here with _____ for the blank",
  "options": ["${sanitizedWord}", "distractor1", "distractor2", "distractor3", "distractor4"],
  "correctIndex": 0,
  "explanations": [
    "'${sanitizedWord}' is correct because [explain specific context clues].",
    "'Distractor1' is wrong because [explain why it doesn't fit the specific context].",
    "'Distractor2' is wrong because [explain why it doesn't fit the specific context].",
    "'Distractor3' is wrong because [explain why it doesn't fit the specific context].",
    "'Distractor4' is wrong because [explain why it doesn't fit the specific context]."
  ]
}`;
    }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DEFENSIVE STATE MANAGEMENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const AppState = {
    correct: 0,
    total: 0,
    currentQuestion: null,
    prefetched: null,
    isFirstQuestion: true,
    
    // Request management
    abortController: null,
    isLoading: false,
    prefetchPromise: null,
    
    // Circuit breaker
    consecutiveFailures: 0,
    circuitOpenUntil: 0,
    
    // Rate limiting
    lastButtonClick: 0,
    
    // Answer state
    hasAnswered: false,
    
    reset() {
        this.correct = 0;
        this.total = 0;
        this.currentQuestion = null;
        this.prefetched = null;
        this.isFirstQuestion = true;
        this.hasAnswered = false;
    },
    
    cancelPendingRequests() {
        if (this.abortController) {
            this.abortController.abort();
            this.abortController = null;
        }
    }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UTILITY FUNCTIONS - DEFENSIVE HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * DEFENSE: Global error handler - catches all unhandled errors
 * PROTECTS AGAINST: White screen crashes from unexpected exceptions
 */
window.addEventListener('error', (event) => {
    console.error('Global error caught:', event.error);
    showGlobalError();
    event.preventDefault();
});

window.addEventListener('unhandledrejection', (event) => {
    console.error('Unhandled promise rejection:', event.reason);
    showNotification('error', 'Something unexpected happened. Please refresh if issues continue.');
    event.preventDefault();
});

/**
 * DEFENSE: DOM Content Loaded validation
 * PROTECTS AGAINST: MYWORDS not loaded, missing elements
 */
document.addEventListener('DOMContentLoaded', () => {
    // Validate MYWORDS exists and is valid
    if (typeof MYWORDS === 'undefined' || !Array.isArray(MYWORDS) || MYWORDS.length === 0) {
        console.error('MYWORDS is not properly defined');
        showGlobalError('Word list failed to load. Please refresh the page.');
        return;
    }
    
    // Validate critical DOM elements exist
    const criticalElements = ['welcomePage', 'appPage', 'btnStart', 'loading', 'questionArea'];
    const missing = criticalElements.filter(id => !document.getElementById(id));
    if (missing.length > 0) {
        console.error('Missing critical DOM elements:', missing);
        showGlobalError('Page failed to load correctly. Please refresh.');
        return;
    }
    
    // Initialize offline detection
    initOfflineDetection();
    
    // Start prefetching first question
    prefetchQuestion();
});

/**
 * DEFENSE: XSS Sanitization
 * PROTECTS AGAINST: Script injection from AI-generated content
 */
function sanitizeHtml(text) {
    if (typeof text !== 'string') return '';
    
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

/**
 * DEFENSE: Input validation for API responses
 * PROTECTS AGAINST: Malformed AI responses, missing fields
 */
function validateQuestion(data) {
    if (!data || typeof data !== 'object') {
        throw new Error('Invalid question data: not an object');
    }
    
    // Required fields
    if (typeof data.sentence !== 'string' || !data.sentence.trim()) {
        throw new Error('Invalid question: missing or empty sentence');
    }
    
    if (!Array.isArray(data.options) || data.options.length !== 5) {
        throw new Error('Invalid question: options must be an array of 5 items');
    }
    
    if (typeof data.correctIndex !== 'number' || data.correctIndex < 0 || data.correctIndex > 4) {
        throw new Error('Invalid question: correctIndex must be 0-4');
    }
    
    // Validate all options are strings
    for (let i = 0; i < data.options.length; i++) {
        if (typeof data.options[i] !== 'string') {
            throw new Error(`Invalid question: option ${i} is not a string`);
        }
    }
    
    // Validate explanations if present
    if (data.explanations && !Array.isArray(data.explanations)) {
        throw new Error('Invalid question: explanations must be an array');
    }
    
    // Length limits (prevent memory issues)
    if (data.sentence.length > CONFIG.maxSentenceLength) {
        data.sentence = data.sentence.substring(0, CONFIG.maxSentenceLength) + '...';
    }
    
    data.options = data.options.map(opt => 
        opt.length > CONFIG.maxOptionLength ? opt.substring(0, CONFIG.maxOptionLength) + '...' : opt
    );
    
    return true;
}

/**
 * DEFENSE: Debounce function
 * PROTECTS AGAINST: Double-clicking, rapid-fire button clicks
 */
function debounce(fn, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => fn.apply(this, args), delay);
    };
}

/**
 * DEFENSE: Rate limit check
 * PROTECTS AGAINST: Button spam, accidental double-clicks
 */
function checkRateLimit() {
    const now = Date.now();
    if (now - AppState.lastButtonClick < CONFIG.debounceDelay) {
        return false;
    }
    AppState.lastButtonClick = now;
    return true;
}

/**
 * DEFENSE: Sleep/delay utility for retries
 */
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * DEFENSE: Circuit breaker check
 * PROTECTS AGAINST: Cascading failures, hammering a failing API
 */
function isCircuitOpen() {
    if (AppState.consecutiveFailures >= CONFIG.circuitBreakerThreshold) {
        if (Date.now() < AppState.circuitOpenUntil) {
            return true;
        }
        // Reset circuit after timeout
        AppState.consecutiveFailures = 0;
    }
    return false;
}

function recordSuccess() {
    AppState.consecutiveFailures = 0;
}

function recordFailure() {
    AppState.consecutiveFailures++;
    if (AppState.consecutiveFailures >= CONFIG.circuitBreakerThreshold) {
        AppState.circuitOpenUntil = Date.now() + CONFIG.circuitBreakerTimeout;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NOTIFICATION & ERROR DISPLAY SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function showNotification(type, message, duration = 5000) {
    const container = document.getElementById('notificationContainer');
    if (!container) return;
    
    const icons = {
        error: 'âŒ',
        warning: 'âš ï¸',
        info: 'â„¹ï¸',
        success: 'âœ…'
    };
    
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.innerHTML = `
        <span class="notification-icon">${icons[type] || 'â„¹ï¸'}</span>
        <span>${sanitizeHtml(message)}</span>
        <button class="notification-close" onclick="this.parentElement.remove()">Ã—</button>
    `;
    
    container.appendChild(notification);
    
    // Auto-remove after duration
    if (duration > 0) {
        setTimeout(() => {
            if (notification.parentElement) {
                notification.remove();
            }
        }, duration);
    }
    
    return notification;
}

function showGlobalError(message = null) {
    const boundary = document.getElementById('globalErrorBoundary');
    if (boundary) {
        if (message) {
            const p = boundary.querySelector('p');
            if (p) p.textContent = message;
        }
        boundary.classList.add('active');
    }
}

function hideGlobalError() {
    const boundary = document.getElementById('globalErrorBoundary');
    if (boundary) {
        boundary.classList.remove('active');
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OFFLINE DETECTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function initOfflineDetection() {
    const updateOnlineStatus = () => {
        const indicator = document.getElementById('offlineIndicator');
        if (!indicator) return;
        
        if (navigator.onLine) {
            indicator.classList.remove('active');
            // Try to prefetch if we were offline
            if (!AppState.prefetched && !AppState.isLoading) {
                prefetchQuestion();
            }
        } else {
            indicator.classList.add('active');
            showNotification('warning', 'You\'re offline. Check your connection to continue.', 3000);
        }
    };
    
    window.addEventListener('online', updateOnlineStatus);
    window.addEventListener('offline', updateOnlineStatus);
    updateOnlineStatus();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DOM ELEMENT REFERENCES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const $ = id => document.getElementById(id);

// Use a getter pattern to handle cases where elements might not exist yet
const DOM = {
    get welcomePage() { return $('welcomePage'); },
    get appPage() { return $('appPage'); },
    get btnStart() { return $('btnStart'); },
    get btnBack() { return $('btnBack'); },
    get loading() { return $('loading'); },
    get loadingText() { return $('loadingText'); },
    get questionArea() { return $('questionArea'); },
    get sentence() { return $('sentence'); },
    get options() { return $('options'); },
    get feedback() { return $('feedback'); },
    get feedbackText() { return $('feedbackText'); },
    get btnNext() { return $('btnNext'); },
    get scoreEl() { return $('score'); },
    get errorState() { return $('errorState'); },
    get errorMessage() { return $('errorMessage'); },
    get btnRetry() { return $('btnRetry'); }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// API FUNCTIONS - WITH COMPREHENSIVE ERROR HANDLING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * DEFENSE: Fetch with timeout and abort support
 * PROTECTS AGAINST: Hanging requests, slow networks
 */
async function fetchWithTimeout(url, options = {}, timeoutMs = CONFIG.apiTimeout) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
    
    try {
        const response = await fetch(url, {
            ...options,
            signal: controller.signal
        });
        clearTimeout(timeoutId);
        return response;
    } catch (error) {
        clearTimeout(timeoutId);
        if (error.name === 'AbortError') {
            throw new Error('Request timed out. Please check your connection.');
        }
        throw error;
    }
}

/**
 * DEFENSE: Generate question with retry logic and circuit breaker
 * PROTECTS AGAINST: Network failures, API errors, timeout
 */
async function generateQuestion(attempt = 1) {
    // Check circuit breaker
    if (isCircuitOpen()) {
        const waitSeconds = Math.ceil((AppState.circuitOpenUntil - Date.now()) / 1000);
        throw new Error(`Too many failures. Please wait ${waitSeconds} seconds before trying again.`);
    }
    
    // Check online status
    if (!navigator.onLine) {
        throw new Error('You\'re offline. Please check your internet connection.');
    }
    
    // Validate MYWORDS
    if (!Array.isArray(MYWORDS) || MYWORDS.length === 0) {
        throw new Error('Word list is not available.');
    }
    
    const word = MYWORDS[Math.floor(Math.random() * MYWORDS.length)];
    
    let prompt;
    try {
        prompt = CONFIG.getPrompt(word);
    } catch (error) {
        throw new Error('Failed to generate question prompt: ' + error.message);
    }
    
    try {
        const response = await fetchWithTimeout('/api/question', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                prompt: prompt,
                model: CONFIG.model,
                temperature: CONFIG.temperature,
                maxTokens: CONFIG.maxTokens
            })
        });
        
        if (!response.ok) {
            let errorMessage = `Server error (${response.status})`;
            
            // Specific error messages for common status codes
            switch (response.status) {
                case 401:
                    errorMessage = 'Authentication failed. Please contact support.';
                    break;
                case 404:
                    errorMessage = 'Question service not found. Please try again later.';
                    break;
                case 429:
                    errorMessage = 'Too many requests. Please wait a moment.';
                    break;
                case 500:
                case 502:
                case 503:
                case 504:
                    errorMessage = 'Server is busy. Please try again in a moment.';
                    break;
            }
            
            throw new Error(errorMessage);
        }
        
        const data = await response.json();
        
        // DEFENSE: Validate response structure
        if (!data || typeof data !== 'object') {
            throw new Error('Invalid response from server');
        }
        
        if (!data.choices || !Array.isArray(data.choices) || data.choices.length === 0) {
            throw new Error('Invalid response format from AI service');
        }
        
        if (!data.choices[0].message || typeof data.choices[0].message.content !== 'string') {
            throw new Error('Missing question content in response');
        }
        
        const text = data.choices[0].message.content;
        
        // DEFENSE: Robust JSON parsing with multiple fallbacks
        let question;
        const parseErrors = [];
        
        // Try 1: Direct parse
        try {
            question = JSON.parse(text);
        } catch (e) {
            parseErrors.push(e.message);
            
            // Try 2: Clean control characters
            try {
                const cleaned = text.replace(/[\x00-\x1F\x7F]/g, ' ');
                question = JSON.parse(cleaned);
            } catch (e2) {
                parseErrors.push(e2.message);
                
                // Try 3: Extract JSON from markdown code blocks
                try {
                    const jsonMatch = text.match(/```(?:json)?\s*([\s\S]*?)```/);
                    if (jsonMatch) {
                        question = JSON.parse(jsonMatch[1].trim());
                    } else {
                        // Try 4: Find JSON object pattern
                        const objMatch = text.match(/\{[\s\S]*"sentence"[\s\S]*"options"[\s\S]*\}/);
                        if (objMatch) {
                            question = JSON.parse(objMatch[0]);
                        }
                    }
                } catch (e3) {
                    parseErrors.push(e3.message);
                    throw new Error('Could not parse question data after multiple attempts');
                }
            }
        }
        
        // DEFENSE: Validate parsed question
        validateQuestion(question);
        
        // Success! Reset failure count
        recordSuccess();
        
        return question;
        
    } catch (error) {
        // DEFENSE: Retry logic for transient failures
        const isRetryable = error.message.includes('timeout') ||
                           error.message.includes('network') ||
                           error.message.includes('busy') ||
                           error.message.includes('Server error');
        
        if (isRetryable && attempt < CONFIG.retryAttempts) {
            const delay = CONFIG.retryDelay * Math.pow(2, attempt - 1); // Exponential backoff
            
            if (DOM.loadingText) {
                DOM.loadingText.textContent = `Retrying... (${attempt}/${CONFIG.retryAttempts})`;
            }
            
            await sleep(delay);
            return generateQuestion(attempt + 1);
        }
        
        // Record failure for circuit breaker
        recordFailure();
        throw error;
    }
}

/**
 * DEFENSE: Prefetch with duplicate request prevention
 * PROTECTS AGAINST: Multiple simultaneous prefetch requests
 */
async function prefetchQuestion() {
    // Don't prefetch if already have one
    if (AppState.prefetched) return;
    
    // Don't prefetch if already fetching
    if (AppState.prefetchPromise) return;
    
    // Create a single promise that can be shared
    AppState.prefetchPromise = generateQuestion()
        .then(question => {
            AppState.prefetched = question;
            AppState.prefetchPromise = null;
        })
        .catch(error => {
            console.error('Prefetch failed:', error);
            AppState.prefetchPromise = null;
            // Don't show error for prefetch failures - silent fail
        });
    
    return AppState.prefetchPromise;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VIEW MANAGEMENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function showApp() {
    // DEFENSE: Rate limit start button
    if (!checkRateLimit()) return;
    
    // DEFENSE: Check MYWORDS
    if (!Array.isArray(MYWORDS) || MYWORDS.length === 0) {
        showNotification('error', 'Word list is not available. Please refresh the page.');
        return;
    }
    
    if (DOM.welcomePage) DOM.welcomePage.classList.remove('active');
    if (DOM.appPage) DOM.appPage.classList.add('active');
    
    // Use prefetched question if available (instant display)
    if (AppState.prefetched && AppState.isFirstQuestion) {
        AppState.isFirstQuestion = false;
        showLoading(false);
        AppState.currentQuestion = AppState.prefetched;
        AppState.prefetched = null;
        displayQuestion();
        // Prefetch next one in background
        prefetchQuestion();
    } else {
        loadQuestion();
    }
}

function showWelcome() {
    // DEFENSE: Cancel any pending requests when going back
    AppState.cancelPendingRequests();
    AppState.reset();
    
    if (DOM.appPage) DOM.appPage.classList.remove('active');
    if (DOM.welcomePage) DOM.welcomePage.classList.add('active');
    
    // Reset score display
    if (DOM.scoreEl) DOM.scoreEl.textContent = '0 / 0';
    
    // Prefetch for next time
    prefetchQuestion();
}

function showLoading(show) {
    AppState.isLoading = show;
    if (DOM.loading) DOM.loading.classList.toggle('hidden', !show);
    if (DOM.questionArea) DOM.questionArea.classList.toggle('hidden', show);
    if (DOM.errorState) DOM.errorState.classList.add('hidden');
}

function showError(message, showRetry = true) {
    showLoading(false);
    if (DOM.questionArea) DOM.questionArea.classList.add('hidden');
    if (DOM.errorState) {
        DOM.errorState.classList.remove('hidden');
        if (DOM.errorMessage) DOM.errorMessage.textContent = message;
        if (DOM.btnRetry) DOM.btnRetry.style.display = showRetry ? 'block' : 'none';
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// QUESTION LOADING & DISPLAY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function loadQuestion() {
    // DEFENSE: Prevent concurrent loads
    if (AppState.isLoading) return;
    
    // DEFENSE: Reset answer state
    AppState.hasAnswered = false;
    
    showLoading(true);
    if (DOM.loadingText) DOM.loadingText.textContent = 'Generating question...';
    
    // Scroll to top when loading new question
    window.scrollTo({ top: 0, behavior: 'smooth' });
    
    try {
        // Use prefetched question or generate new one
        if (AppState.prefetched) {
            AppState.currentQuestion = AppState.prefetched;
            AppState.prefetched = null;
        } else {
            AppState.currentQuestion = await generateQuestion();
        }
        
        displayQuestion();
        showLoading(false);
        
        // Prefetch next one in background
        prefetchQuestion();
        
    } catch (error) {
        console.error('Failed to load question:', error);
        
        // User-friendly error messages
        let userMessage = 'Couldn\'t load the question.';
        let showRetry = true;
        
        if (error.message.includes('offline')) {
            userMessage = 'You\'re offline. Check your connection and try again.';
        } else if (error.message.includes('timeout')) {
            userMessage = 'The server is taking too long. Please try again.';
        } else if (error.message.includes('Too many')) {
            userMessage = error.message;
            showRetry = false;
        } else if (error.message.includes('circuit')) {
            userMessage = 'Service temporarily unavailable. Please wait a moment.';
            showRetry = false;
        }
        
        showError(userMessage, showRetry);
    }
}

function displayQuestion() {
    const question = AppState.currentQuestion;
    
    // DEFENSE: Validate question before display
    if (!question) {
        showError('Something went wrong. Please try again.');
        return;
    }
    
    try {
        // DEFENSE: Sanitize and display sentence (XSS protection)
        const sentenceHtml = sanitizeHtml(question.sentence)
            .replace(/_{3,}/g, '<span class="blank">_____</span>');
        
        if (DOM.sentence) DOM.sentence.innerHTML = sentenceHtml;
        
        // Shuffle options with original indices preserved
        const originalCorrectIndex = question.correctIndex;
        const indexed = question.options.map((opt, i) => ({ 
            opt, 
            origIndex: i, 
            explanation: question.explanations?.[i] 
        }));
        
        // DEFENSE: Fisher-Yates shuffle with validation
        if (indexed.length !== 5) {
            throw new Error('Invalid options count');
        }
        
        for (let i = indexed.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [indexed[i], indexed[j]] = [indexed[j], indexed[i]];
        }
        
        question.options = indexed.map(x => x.opt);
        question.correctIndex = indexed.findIndex(x => x.origIndex === originalCorrectIndex);
        if (question.explanations) {
            question.explanations = indexed.map(x => x.explanation);
        }
        
        // DEFENSE: Validate shuffled indices
        if (question.correctIndex < 0 || question.correctIndex > 4) {
            throw new Error('Shuffle algorithm error');
        }
        
        // Render options with sanitization
        const keys = ['A', 'B', 'C', 'D', 'E'];
        if (DOM.options) {
            DOM.options.innerHTML = question.options.map((opt, i) => `
                <button class="option" data-index="${i}" type="button">
                    <span class="key">${keys[i]}</span>
                    <span>${sanitizeHtml(opt)}</span>
                </button>
            `).join('');
            
            // DEFENSE: Use event delegation and check for disabled state
            DOM.options.querySelectorAll('.option').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (!AppState.hasAnswered && !btn.disabled) {
                        selectAnswer(+btn.dataset.index);
                    }
                });
            });
        }
        
        if (DOM.feedback) DOM.feedback.classList.add('hidden');
        if (DOM.btnNext) DOM.btnNext.classList.add('hidden');
        
    } catch (error) {
        console.error('Error displaying question:', error);
        showError('Failed to display question. Please try again.');
    }
}

function selectAnswer(index) {
    // DEFENSE: Prevent multiple answers
    if (AppState.hasAnswered) return;
    AppState.hasAnswered = true;
    
    // DEFENSE: Validate index
    if (typeof index !== 'number' || index < 0 || index > 4) {
        console.error('Invalid answer index:', index);
        return;
    }
    
    const question = AppState.currentQuestion;
    if (!question || typeof question.correctIndex !== 'number') {
        console.error('No valid question state');
        return;
    }
    
    const isCorrect = index === question.correctIndex;
    
    // Update score
    AppState.total++;
    if (isCorrect) AppState.correct++;
    if (DOM.scoreEl) DOM.scoreEl.textContent = `${AppState.correct} / ${AppState.total}`;
    
    // Update UI with visual feedback
    const optionButtons = DOM.options ? DOM.options.querySelectorAll('.option') : [];
    optionButtons.forEach((btn, i) => {
        btn.disabled = true;
        if (i === index) btn.classList.add(isCorrect ? 'correct' : 'incorrect');
        if (i === question.correctIndex && !isCorrect) btn.classList.add('revealed');
    });
    
    // Build feedback HTML with sanitization
    const keys = ['A', 'B', 'C', 'D', 'E'];
    let feedbackHTML = '';
    
    if (question.explanations && question.explanations.length === 5) {
        feedbackHTML = '<div class="explanation-list">';
        question.options.forEach((opt, i) => {
            const isOptCorrect = i === question.correctIndex;
            const explanation = question.explanations[i] || '';
            feedbackHTML += `
                <div class="explanation-item ${isOptCorrect ? 'correct' : 'wrong'}">
                    <span class="opt-label">${keys[i]}</span>
                    <span class="opt-text"><strong>${sanitizeHtml(opt)}:</strong> ${sanitizeHtml(explanation)}</span>
                </div>
            `;
        });
        feedbackHTML += '</div>';
    } else {
        feedbackHTML = `<p>${isCorrect ? 'âœ… Correct!' : 'âŒ Incorrect. The correct answer is shown above.'}</p>`;
    }
    
    if (DOM.feedbackText) DOM.feedbackText.innerHTML = feedbackHTML;
    if (DOM.feedback) DOM.feedback.classList.remove('hidden');
    if (DOM.btnNext) DOM.btnNext.classList.remove('hidden');
    
    // Scroll to show Next button on small screens
    setTimeout(() => {
        if (DOM.btnNext) {
            DOM.btnNext.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
    }, 100);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EVENT LISTENERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// DEFENSE: Debounced start button
if (DOM.btnStart) {
    DOM.btnStart.addEventListener('click', debounce(showApp, CONFIG.debounceDelay));
}

// DEFENSE: Debounced back button
if (DOM.btnBack) {
    DOM.btnBack.addEventListener('click', debounce(showWelcome, CONFIG.debounceDelay));
}

// DEFENSE: Debounced next button
if (DOM.btnNext) {
    DOM.btnNext.addEventListener('click', debounce(() => {
        if (!AppState.isLoading) {
            loadQuestion();
        }
    }, CONFIG.debounceDelay));
}

// DEFENSE: Retry button
if (DOM.btnRetry) {
    DOM.btnRetry.addEventListener('click', debounce(() => {
        loadQuestion();
    }, CONFIG.debounceDelay));
}

// Keyboard shortcuts with state validation
document.addEventListener('keydown', (e) => {
    // DEFENSE: Don't handle if on welcome page or loading
    if (!DOM.appPage || !DOM.appPage.classList.contains('active')) return;
    if (AppState.isLoading) return;
    
    const map = { '1': 0, '2': 1, '3': 2, '4': 3, '5': 4, 'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4 };
    const idx = map[e.key.toLowerCase()];
    
    // Answer selection
    if (idx !== undefined && !AppState.hasAnswered) {
        const btn = DOM.options ? DOM.options.querySelector(`.option[data-index="${idx}"]`) : null;
        if (btn && !btn.disabled) {
            e.preventDefault();
            selectAnswer(idx);
        }
    }
    
    // Next question
    if (e.key === 'Enter' && AppState.hasAnswered && DOM.btnNext && !DOM.btnNext.classList.contains('hidden')) {
        e.preventDefault();
        if (!AppState.isLoading) {
            loadQuestion();
        }
    }
});

// DEFENSE: Handle page visibility changes (pause/resume logic)
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        // Page hidden - cancel non-critical requests
        if (AppState.prefetchPromise && !AppState.currentQuestion) {
            AppState.cancelPendingRequests();
        }
    } else {
        // Page visible again - prefetch if needed
        if (!AppState.prefetched && !AppState.isLoading && DOM.appPage?.classList.contains('active')) {
            prefetchQuestion();
        }
    }
});

// DEFENSE: Handle beforeunload to warn about in-progress requests
window.addEventListener('beforeunload', (e) => {
    if (AppState.isLoading) {
        e.preventDefault();
        e.returnValue = 'A question is loading. Are you sure you want to leave?';
    }
});

// DEFENSE: Image error handling
const welcomeIcon = document.getElementById('welcomeIcon');
if (welcomeIcon) {
    welcomeIcon.addEventListener('error', () => {
        // Hide broken image, show fallback
        welcomeIcon.style.display = 'none';
        const container = document.getElementById('welcomePage');
        if (container) {
            const fallback = document.createElement('div');
            fallback.className = 'welcome-icon';
            fallback.style.display = 'flex';
            fallback.style.alignItems = 'center';
            fallback.style.justifyContent = 'center';
            fallback.style.fontSize = '2rem';
            fallback.textContent = 'ğŸ“š';
            container.insertBefore(fallback, container.firstChild.nextSibling);
        }
    });
}
    </script>
</body>
</html>
